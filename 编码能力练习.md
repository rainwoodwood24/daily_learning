# 编码能力练习

## 一、启航篇

### **1、基础模拟题**

求1000以内（不包括1000）的所有3或5的倍数的和

```c
#include<stdio.h>
#define MAX_N 1000
int main()
{
    int ans=0;
    for(int i=3;i<MAX_N;i++){
        if(i%3==0||i%5==0) ans+=i;
    }
    printf("%d\n",ans);
    return 0;
}
```

是不是最优秀的？怎么衡量？

时间复杂度：跑得快不快

空间复杂度：吃的多不多（越少越好）

程序优化：等差数列公式

```c
#include<stdio.h>
#define MAX_N 1000
int main()
{
    int sum1=(3+999)*(999/3)/2;
    int sum2=(5+995)*(999/5)/2;
    int sum3=(15+999/15*15)*(999/15)/2;
    printf("%d\n",sum1+sum2-sum3);
    return 0;
}
```

第一段代码时间复杂度是O（n)

第二段代码时间复杂度是O（1）

### **2、斐波那契数列**

与第一题很像，就是先告诉我们数的性质，我们要对数进行性质判断以及维护，进而去求得需要的值

>   [!NOTE]
>
>   推导式：我们的重点    生成公式：研究生阶段学习

代码1：

```c
#include<stdio.h>
#define MAX_N 4000000
int f(int n){
    if(n==0||n==1) return 1;
    else return f(n-1)+f(n-2);
}
int main()
{
    int sum=0;
    for(int i=1;;i++){
        if(f(i)<=MAX_N){
            if(!(f(i)%2)) sum+=f(i);
            continue;
        }
        break;
    }
    printf("%d\n",sum);
    return 0;
}
```

代码2：

```c
#include<stdio.h>
#define MAX_N 4000000
int fib[MAX_N+5];
int main()
{
    fib[1]=1,fib[2]=2;
    int sum=2;
    for(int i=3;;i++){
        fib[i]=fib[i-1]+fib[i-2];
        if(fib[i]<=MAX_N){
            if(fib[i]%2==0) sum+=fib[i];
            continue;
        }
        break;
    }
    printf("%d\n",sum);
    return 0;
}
```

>   [!IMPORTANT]
>
>   **代码3：滑动数组(滚动数组)//将空间复杂度优化成O（1）**

```c
#include<stdio.h>
#define MAX_N 4000000

int fib[3]={0,1,2};
int main()
{
    int n=2,sum=2;
    while(fib[(n-1)%3]+fib[n%3]<=MAX_N)
    {
        n+=1;
        fib[n%3]=fib[(n-1)%3]+fib[(n-2)%3];
        if(!(fib[n%3]&1)) sum+=fib[n%3];//if(fib[n%3]%2==0) sum+=fib[n%3];位运算是所有运算中最快的一类运算，而求余运算是最慢的
    }
    printf("%d\n",sum);
    return 0;
}
```

代码4：两个变量

```c
#include<stdio.h>
#define MAX_N 4000000
int main()
{
    int a=1,b=2,sum=2;
    while(a+b<=MAX_N){
        a=a+b;//接下来将a,b值交换  
        a^=b;
        b^=a;
        a^=b;
        if(!(b&1)) sum+=b;
    }
    printf("%d\n",sum);
    return 0;
}
```

```c
#include<stdio.h>
#define MAX_N 4000000
int main()
{
    int a=1,b=2,sum=2;
    while(a+b<=MAX_N){
        b=a+b;
        a=b-a;
        if(!(b&1)) sum+=b;
    }
    printf("%d\n",sum);
    return 0;
}
```



### 3、EP04：最大回文乘积

```c
#include<stdio.h>
int f(int n){
    int sum=0,temp=n;
    while(temp){
        sum=sum*10+temp%10;
        temp/=10;
    }
    return n==sum;
}
int main()
{
    int max=0;
    for(int i=100;i<1000;i++){
        for(int j=100;j<1000;j++){
            if(f(i*j)){
                if(max>f(i*j)) max=f(i*j);
            }
            continue;
        }
    }
    printf("%d\n",max);
    return 0;
}
```

**改进代码：**

1、编码上：过多的缩进会导致代码的可读性比较差，line 15-20改进

2、重复枚举：循环里改进第二层代码

3、回文数判断更为复杂，所以先判断大小

4、改变循环内遍历顺序，使得先遍历的数得到的回文数更大

```c
#include<stdio.h>
int f(int n){
    int sum=0,temp=n;
    while(temp){
        sum=sum*10+temp%10;
        temp/=10;
    }
    return n==sum;
}
int main()
{
    int max=0;
    for(int i=999;i>=100;i--){
        for(int j=i;j>=100;j--){
            if((max>f(i*j))||!f(i*j)){
               continue;
            }
             max=f(i*j);
             continue;
        }
    }
    printf("%d\n",max);
    return 0;
}
```

>   [!IMPORTANT]
>
>   **拓展：任意进制转化(数字翻转问题）**

```c
int is_reverse(int n,int base){
    int sum=0,temp=n;
    while(temp){
        sum=sum*base+temp%base;
        temp/=base;
    }
    return n==sum;
}
```

### 4、EP06:平方和与和平方之差

```c
#include<stdio.h>
#define MAX_N 100
int main()
{
	int sum1=0,sum2=0;
	for(int i=1;i<=MAX_N;i++){
		sum1+=i*i;
		sum2+=i;
	}
	sum2=sum2*sum2;
	printf("%d\n",sum2-sum1);
	return 0;
}
```

代码优化：

```c
#include<stdio.h>
int main()
{
	int sum1=0,sum2=0,n=100;
	sum1=n*(n+1)*(2*n+1)/6;
    sum2=(1+n)*n/2;
	sum2=sum2*sum2;
	printf("%d\n",sum2-sum1);
	return 0;
}
```

### 5、EP30:各位数字的五次幂

>   [!CAUTION]
>
>   **难度：确定枚举上限**

10^n = 9^5 *n

得出n=6是上限

```c
#include<stdio.h>
#include<math.h>
#define MAX_N 9*8*7*6*5*4*3*2*1*6
int f(int n){
	int temp=n,sum=0;
	while(temp){
		sum+=pow(temp%10,5);
		temp/=10;
	}
	return sum==n;
}
int main()
{
	int sum=0;
	for(int i=2;i<MAX_N;i++){
		if(!f(i)) continue;
		sum+=i;
	}
	printf("%d\n",sum);
	return 0;
}
```

### 6、EP34:数字阶乘和

```c
#include<stdio.h>
#include<math.h>
#define MAX_N 9*8*7*6*5*4*3*2*1*7
int fac(int n){
	if(n<0) return 0;
	else if(n==1||n==0) return 1;
	else return fac(n-1)*n;
}
int f(int n){
	int temp=n,sum=0;
	while(temp){
		sum+=fac(temp%10);
		temp/=10;
	}
	return n==sum;
}
int main()
{
	int sum=0;
	for(int i=3;i<MAX_N;i++){
		if(!f(i)) continue;
		sum+=i;
	}
	printf("%d\n",sum);
	return 0;
}
```

代码改进：

>   [!IMPORTANT]
>
>   用打表的方式，避免重复计算阶乘

```c
int fac[10]={1};
void init_fac(){
    for(int i=1;i<10;i++){
        fac[i]=fac[i-1]*i;
    }
    return ;
}
```

改进后的全部代码

```c
#include<stdio.h>
#include<math.h>
#define MAX_N 9*8*7*6*5*4*3*2*1*7
int fac[10]={1};
void init_fac(){
    for(int i=1;i<10;i++){
        fac[i]=fac[i-1]*i;
    }
    return ;
}
int f(int n){
	int temp=n,sum=0;
	while(temp){
		sum+=fac(temp%10);
		temp/=10;
	}
	return n==sum;
}
int main()
{
	int sum=0;
	for(int i=3;i<MAX_N;i++){
		if(!f(i)) continue;
		sum+=i;
	}
	printf("%d\n",sum);
	return 0;
}
```

### 7、EP36：双进制回文数

就是EP04的扩展，没有任何难度

```c
#include<stdio.h>
#define MAX_N 1000000
int f(int n,int base){
	int temp=n,sum=0;
	while(temp){
		sum=sum*base+temp%base;
		temp/=base;
	}
	return sum==n;
}
int main()
{
	int sum=0;
	for(int i=1;i<MAX_N;i++){
		if(!f(i,2)||!f(i,10)) {
			continue;
		}
		sum+=i;
	}
	printf("%d\n",sum);
	return 0;
}
```

### 8、EP28：螺旋数阵对角线

**题目不难，难在找规律**，看到这种题的第一印象是比较新颖

找对角线与边长的关系

```c
#include<stdio.h>
int main()
{
	int sum=1;
	for(int l=3;l<=1001;l+=2){
		sum+=4*l*l-6*l+6;
	}
	printf("%d\n",sum);
	return 0;
}
```


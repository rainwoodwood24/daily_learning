# 树与二叉树

## 一、计算机中的树形结构

叶子节点：没有子节点

### 1、树形结构的定义

如果树形结构只有一条分支，那就是一条链表，故树——结构定义如下

```c
typedef struct Node{
    int data;
    struct Node *next;
}Node,*LinkedList;
```

若最多指向3个节点,三叉树最简单结构定义

```c
typedef struct Node{
    int data;
    struct Node *next[3];
}Node,*Tree;
```

**单向链表结构是树形结构的特例**

### 2、树——深度、高度和度

结点的深度和高度——类比井的深度，楼房的高度

1. 深度：从上往下数（从根结点开始数，0开始）
2. 高度：从底往上数（从叶子结点开始数，0开始）
3. 度：子节点个数
   - 入度：谁指向我
   - 出度：我指向谁

### 3、树结构：深入理解

树的节点代表【集合】，边代表【关系】

**根结点代表全集**



### 4、树——遍历的两种方式

|                      栈                      |                       队列                       |
| :------------------------------------------: | :----------------------------------------------: |
| 树的**深度遍历**、深度优先搜索（图算法基础） | 树的**层序遍历**，**广度优先搜索**（图算法基础） |



## 二、二叉树：结构讲解

### 1、二叉树的基本定义

1. 每个节点最多有两个子孩子
2. **度为0的节点比度为2的节点多1个**

点数=边数+1——>n0+n1+n2=0*n0+n1+2*n2+1

推出：n0=n2+1;



### 2、二叉树：特殊种类

- 完全二叉树(complete binary tree)：除最下面层，全都是满的，最后一层只缺少最右侧的节点
- 满二叉树(full binary tree)：没有度为1的节点
- 完美二叉树(perfect binary tree)：每一层都是满的

**注：中文资料中——完美二叉树与满二叉树需要根据具体情况判断**

**英文资料中就是以上定义**



完全二叉树的性质：

- 编号为i的子节点(根结点为1）：

  左孩子：2*i

  右孩子：2*i+1

  计算：时间换空间

- 可以用连续空间存储（数组）



二叉树：作用三：左孩子右兄弟表示法节省空间

eg.任何叉树都可以转换成二叉树，而二叉树用指针空间定义，三叉树需要更多指针空间

k叉树节省空间=k*n-2*n;

```c
#include<stdio.h>
#include<stdlib.h>
#include<time.h>
typedef struct Node{
    int key;
    stuct Node *lchild,*rchild;
}Node;

Node *getNewNode(int key){
    Node *p=(Node *)malloc(sizeof(Node));
    p->key=key;
    p->lchild=p->rchild=NULL;
    return p;
}

Node *insert(Node *root,int key){
	if(root==NULL) return getNewNode(key);
    if(rand()%2==1) root->lchild=insert(root->lchild,key);
    else root->rchild=inser(root->rchild,key);
    return root;
}


void clear(Node *root){
    if(root==NULL) return;
    clear(root->lchild);
    clear(root->rchild);
    free(root);
    return;
}

//数组模拟队列（连续存储空间）
int queue[15],head,tail;
void bfs(Node *root){
    head=tail=0;
    queue[tail++]=root;
    while(head<tail){
        Node *node=queue[head];
        printf("%d",node->key);
        if(node->lchild) queue[tail++]=node->lchild;
        if(node->rchild) queue[tail++]=node->rchild;
        head++;
    }
    return;
}

int tot=0;
void dfs(Node *root){
    if(root==NULL) return;
    int start,end;
    tot++;
    start=tot;
    if(root->lchild) dfs(root->lchild);
    if(root->rchild) dfs(root->rchild);
    tot++;
    end=tot;
    printf("%d:[%d,%d]\n",root->key,start,end);
    return;
}

int main()
{
    srand(time(0));
    Node *root=NULL;
    for(int i=0;i<10;i++){
        root=insert(root,rand()%100);
    }
    bfs(root);
    dfs(root);
    return 0;
}

```



